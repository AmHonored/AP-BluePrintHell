package com.networkgame.model.entity.packettype.messenger;

import com.networkgame.model.entity.Packet;
import com.networkgame.model.entity.Port;
import javafx.geometry.Point2D;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import java.util.Random;

/**
 * ProtectedPacket is a messenger packet that appears as a purple lozenge but internally
 * contains a hidden packet type (Square, Triangle, or Hexagon). Its true identity is
 * only revealed when it reaches DDoS or Spy systems.
 * 
 * Features:
 * - Double health points of the underlying packet type
 * - Movement characteristics of the underlying packet type
 * - Adds 5 coins when reaching end systems
 * - Only generated by VPN systems
 * - Reveals true type when reaching DDoS or Spy systems
 */
public class ProtectedPacket extends Packet {
    
    // Constants for appearance and behavior
    private static final double VISUAL_SIZE = 16.0;
    private static final double DEFAULT_SPEED = 90.0;
    private static final Random random = new Random();
    
    // Probability weights for underlying packet types [Square, Triangle, Hexagon]
    // Based on the format: square=2, triangle=3, hexagon=2 (total=7)
    private static final int[] TYPE_WEIGHTS = {2, 3, 2}; // Square, Triangle, Hexagon
    
    // The hidden underlying packet type (what it reverts to when VPN fails)
    private final PacketType underlyingType;
    private final int underlyingSize;
    private final double underlyingSpeed;
    
    // The disguise movement type (how it behaves while protected)
    private final PacketType disguiseMovementType;
    private boolean isRevealed = false;
    
    /**
     * Creates a new ProtectedPacket at the specified position.
     * The underlying packet type is randomly selected based on probability weights.
     * 
     * @param position The initial position of the packet
     */
    public ProtectedPacket(Point2D position) {
        this(position, selectRandomUnderlyingType(), selectRandomMovementType());
    }
    
    /**
     * Creates a new ProtectedPacket with a specific underlying type.
     * This is used by VPN systems when converting existing packets.
     * 
     * @param position The initial position of the packet
     * @param underlyingType The original packet type (what it will revert to)
     */
    public ProtectedPacket(Point2D position, PacketType underlyingType) {
        this(position, underlyingType, selectRandomMovementType());
    }
    
    /**
     * Private constructor that takes the underlying type and disguise movement type.
     * This ensures consistency between size calculation and stored types.
     */
    private ProtectedPacket(Point2D position, PacketType underlyingType, PacketType disguiseMovementType) {
        super(position, PacketType.PROTECTED, calculateDoubleSize(underlyingType));
        
        this.underlyingType = underlyingType;
        this.disguiseMovementType = disguiseMovementType;
        this.underlyingSize = getUnderlyingSizeForType(underlyingType);
        this.underlyingSpeed = getUnderlyingSpeedForType(underlyingType);
        this.currentSpeed = getUnderlyingSpeedForType(disguiseMovementType); // Use disguise speed
        
        initializeShape(position);
        
        // Store underlying type as a property for later revelation
        setProperty("underlyingType", underlyingType);
        setProperty("disguiseMovementType", disguiseMovementType);
        setProperty("protected", true);
        setProperty("isProtectedPacket", true);
    }
    
    /**
     * Selects a random underlying packet type based on probability weights.
     * Weights: Square=2/7, Triangle=3/7, Hexagon=2/7
     */
    private static PacketType selectRandomUnderlyingType() {
        int totalWeight = TYPE_WEIGHTS[0] + TYPE_WEIGHTS[1] + TYPE_WEIGHTS[2];
        int randomValue = random.nextInt(totalWeight);
        
        if (randomValue < TYPE_WEIGHTS[0]) {
            return PacketType.SQUARE;
        } else if (randomValue < TYPE_WEIGHTS[0] + TYPE_WEIGHTS[1]) {
            return PacketType.TRIANGLE;
        } else {
            return PacketType.HEXAGON;
        }
    }
    
    /**
     * Selects a random movement type for the protected packet's disguise.
     * This determines how the protected packet behaves while moving through the network.
     * Uses equal probability for all three types (1/3 each).
     */
    private static PacketType selectRandomMovementType() {
        int randomValue = random.nextInt(3); // 0, 1, or 2
        
        switch (randomValue) {
            case 0: return PacketType.SQUARE;
            case 1: return PacketType.TRIANGLE;
            case 2: return PacketType.HEXAGON;
            default: return PacketType.SQUARE; // fallback
        }
    }
    
    /**
     * Calculate double the size of the underlying packet type.
     */
    private static int calculateDoubleSize(PacketType underlyingType) {
        return getUnderlyingSizeForType(underlyingType) * 2;
    }
    
    /**
     * Get the base size for each packet type.
     */
    private static int getUnderlyingSizeForType(PacketType type) {
        switch (type) {
            case SQUARE: return 2;
            case TRIANGLE: return 3;
            case HEXAGON: return 2;
            default: return 2;
        }
    }
    
    /**
     * Get the base speed for each packet type.
     */
    private static double getUnderlyingSpeedForType(PacketType type) {
        switch (type) {
            case SQUARE: return 100.0;
            case TRIANGLE: return 80.0;
            case HEXAGON: return 70.0;
            default: return DEFAULT_SPEED;
        }
    }
    
    /**
     * Initialize the lozenge shape for the protected packet.
     */
    private void initializeShape(Point2D position) {
        Polygon lozenge = new Polygon();
        updateLozengePoints(lozenge, position);
        
        lozenge.setFill(getBaseColor());
        lozenge.setStroke(Color.BLACK);
        lozenge.setStrokeWidth(1.5);
        
        this.shape = lozenge;
    }
    
    /**
     * Updates the lozenge shape points based on position.
     * Creates a diamond/lozenge shape.
     */
    private void updateLozengePoints(Polygon lozenge, Point2D center) {
        double width = VISUAL_SIZE;
        double height = VISUAL_SIZE * 0.7; // Slightly flattened diamond
        
        lozenge.getPoints().clear();
        
        // Create diamond/lozenge shape points
        lozenge.getPoints().addAll(
            center.getX(), center.getY() - height/2,     // Top point
            center.getX() + width/2, center.getY(),      // Right point
            center.getX(), center.getY() + height/2,     // Bottom point
            center.getX() - width/2, center.getY()       // Left point
        );
    }
    
    @Override
    protected void updateShapePosition() {
        if (shape != null && shape instanceof Polygon) {
            updateLozengePoints((Polygon) shape, position);
        }
    }
    
    @Override
    protected Color getBaseColor() {
        if (isRevealed) {
            // Return the color of the underlying packet type when revealed
            switch (underlyingType) {
                case SQUARE: return Color.CORNFLOWERBLUE;
                case TRIANGLE: return Color.ORANGE;
                case HEXAGON: return Color.MEDIUMSEAGREEN;
                default: return Color.MEDIUMPURPLE;
            }
        } else {
            // Show as purple/violet when protected
            return Color.MEDIUMPURPLE;
        }
    }
    
    @Override
    public boolean isCompatible(Port port) {
        // Use the disguise movement type's compatibility (not the underlying type)
        return port.getType() == disguiseMovementType;
    }
    
    /**
     * Adjusts the packet's speed based on port compatibility.
     * Uses the disguise movement type's speed characteristics.
     */
    public void adjustSpeedForPort(Port port) {
        boolean compatible = isCompatible(port);
        
        // Apply speed adjustments based on disguise movement type
        switch (disguiseMovementType) {
            case SQUARE:
                currentSpeed = 100.0 * (compatible ? 0.5 : 1.0);
                break;
            case TRIANGLE:
                currentSpeed = compatible ? 80.0 : 120.0;
                break;
            case HEXAGON:
                currentSpeed = compatible ? 100.0 : 70.0;
                break;
            default:
                currentSpeed = DEFAULT_SPEED;
                break;
        }
        
        setCompatibility(compatible);
        
        // Apply the new speed to velocity while maintaining direction
        if (velocity.magnitude() > 0) {
            velocity = velocity.normalize().multiply(currentSpeed);
        }
    }
    
    /**
     * Reveals the true packet type and transforms the appearance.
     * This should be called when the packet reaches DDoS or Spy systems.
     */
    public void revealTrueType() {
        if (!isRevealed) {
            isRevealed = true;
            setProperty("revealed", true);
            updateShapeAppearance();
            
            System.out.println("ProtectedPacket " + getId() + " revealed as " + underlyingType + 
                             " packet (size: " + underlyingSize + " -> " + getSize() + ")");
        }
    }
    
    /**
     * Checks if this packet has been revealed.
     */
    public boolean isRevealed() {
        return isRevealed;
    }
    
    /**
     * Gets the underlying packet type.
     */
    public PacketType getUnderlyingType() {
        return underlyingType;
    }
    
    /**
     * Gets the disguise movement type (how the packet behaves while protected).
     */
    public PacketType getDisguiseMovementType() {
        return disguiseMovementType;
    }
    
    /**
     * Gets the underlying packet size (before doubling).
     */
    public int getUnderlyingSize() {
        return underlyingSize;
    }
    
    /**
     * Override getCoinValue to return 5 coins for protected packets reaching end systems.
     */
    @Override
    public int getCoinValue() {
        return 5; // Protected packets are worth 5 coins when reaching end systems
    }
    
    /**
     * Updates the packet state each frame.
     */
    @Override
    public void update(double deltaTime) {
        super.update(deltaTime);
        
        // Additional protected packet specific logic can be added here
    }
    
    /**
     * Returns a string representation of the packet for debugging.
     */
    @Override
    public String toString() {
        return String.format("ProtectedPacket{id=%d, underlying=%s, revealed=%s, position=(%.1f,%.1f), speed=%.1f, health=%d/%d}", 
                            getId(), underlyingType, isRevealed, position.getX(), position.getY(), 
                            currentSpeed, getHealth(), getSize());
    }
} 